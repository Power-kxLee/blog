# ES6加厚垒土
万丈高楼起于垒土 巩固基础无疑是最重要了
读书读得最后都是一个寂寞
纸上得来终觉浅，绝知此事要躬行 
所以还得有一留下心得
## let
### 只在代码块的作用域有效
ES6 常用的`let` 类似于`var`对变量的声明 
`var `是在全局作用域都有效
`let`是在代码块的作用域有效
```
{
    var a = 1
    let b = 2
}
a // 1
b // 报错
```
所以 `let`只在声明代码快的作用域有效
### 变量不存在提升
很简单 我们在使用`var`的时候
```
console.log(a)
var a= 2
a // undefined
```
虽然是undefined，但是也奇怪的 强迫症受不了吧
所以let 就不能这样了 你要提升？不存在了 
```
console.log(a) // 报错了
let a = 2
```
### 不允许重复声明
```
var a= 3
var a = 4
a // 4

let b = 1
let b = 2
b // 报错了
```
这代码清楚的很 其实就是不允许 在代码块同一个作用域内 重复声明而已
这里还有一种情况要注意踩坑 那就是 传参不能重复声明
```
function fun(arr) {
    let arr 
}
fun()// 报错了

function fun(arr) {
    {
        let arr = 2
    }
}
fun () // 不报错
```
所以说 别在同一个作用域内 声明一样的变量就行了 
其实这es6是更严谨了 一般来说 自己写的程序很少声明一样的变量 那就是找抽啊

### for循环很好使
```
for (var i = 0 ; i < 10; i ++) {
    setTimeout(function(){
        console.log(i)
      })
}
// 10
```
这里输出10次10 因为`i`是全局变量 每一次循环代码块都是对`i`进行操作
`setTimeout` 在for循环体内 每一次获得都是同一个`i` 循环结束后运行 也就是输出10次10了
我要输出0123456789怎么办 用var改成let就行了
```
 for (let i = 0 ; i < 10; i ++) {
    setTimeout(function(){
        console.log(i)
      })
}
// 0123456789
```
这里代码块工作 每一次循环`i` 都是在当前这次循环内有效 也可以理解成每一次都是一次 新的`i`
竟然每一次都是新的 那么在`setTimeout`代码块内 每一次都是不一样的`i` 也就是最后输出0123456789

我当时看到这里也有疑问 既然每一次都是新的`i` 为什么能记得上一个循环的是几？
这里看了看阮一峰大神的文档  有解释到
```
这是因为 JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮循环的基础上进行计算。
```
反正很牛13就对了

![](./_image/2020-12-11-20-35-01.jpg)

### 我很霸道
let还有一个强制的约定 专业术语`暂时性死区`
看看下面代码
```
var a = 1
{
    console.log(a) // 报错
    let a = 1
}
```
如果按照正常来说 我定义的全局变量`a` 代码往下执行`console`出来的应该是`1`
但是这里就报错了 
ES6这里严格约定 , 只要我代码块内 有声明`let`或者`const` 命令 那么这个代码块就马上给我封闭起来
只要你我声明之前 使用这些变量 我就给你报错
这段语法上 也叫`暂时性死区`
其实这也是属于严谨点 也是好的 我们编写代码 都是一般 先声明在调用 能不使用全局变量 就不使用!
(你特别排除外)


## const
cosnt声明的是一个可读变量 也就是说 只能看 不能更改
这也没什么好说 注意的要点跟let一样 
只知道这个只是可读变量 不能更改就行了


## 块级作用域
js一直都只有全局作用域 和 函数作用域
这样带来很多 麻烦的事情
比如for声明的i 其实在全区作用域一直存活
内层的变量 导致被外层的变量
