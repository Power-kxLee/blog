# ES6加厚垒土
万丈高楼起于垒土 巩固基础无疑是最重要了
读书读得最后都是一个寂寞
纸上得来终觉浅，绝知此事要躬行 
所以还得有一留下心得
## let
### 只在代码块的作用域有效
ES6 常用的`let` 类似于`var`对变量的声明 
`var `是在全局作用域都有效
`let`是在代码块的作用域有效
```
{
    var a = 1
    let b = 2
}
a // 1
b // 报错
```
所以 `let`只在声明代码快的作用域有效
### 变量不存在提升
很简单 我们在使用`var`的时候
```
console.log(a)
var a= 2
a // undefined
```
虽然是undefined，但是也奇怪的 强迫症受不了吧
所以let 就不能这样了 你要提升？不存在了 
```
console.log(a) // 报错了
let a = 2
```
### 不允许重复声明
```
var a= 3
var a = 4
a // 4

let b = 1
let b = 2
b // 报错了
```
这代码清楚的很 其实就是不允许 在代码块同一个作用域内 重复声明而已
这里还有一种情况要注意踩坑 那就是 传参不能重复声明
```
function fun(arr) {
    let arr 
}
fun()// 报错了

function fun(arr) {
    {
        let arr = 2
    }
}
fun () // 不报错
```
所以说 别在同一个作用域内 声明一样的变量就行了 
其实这es6是更严谨了 一般来说 自己写的程序很少声明一样的变量 那就是找抽啊

### for循环很好使
```
for (var i = 0 ; i < 10; i ++) {
    setTimeout(function(){
        console.log(i)
      })
}
// 10
```
这里输出10次10 因为`i`是全局变量 每一次循环代码块都是对`i`进行操作
`setTimeout` 在for循环体内 每一次获得都是同一个`i` 循环结束后运行 也就是输出10次10了
我要输出0123456789怎么办 用var改成let就行了
```
 for (let i = 0 ; i < 10; i ++) {
    setTimeout(function(){
        console.log(i)
      })
}
// 0123456789
```
这里代码块工作 每一次循环`i` 都是在当前这次循环内有效 也可以理解成每一次都是一次 新的`i`
竟然每一次都是新的 那么在`setTimeout`代码块内 每一次都是不一样的`i` 也就是最后输出0123456789

我当时看到这里也有疑问 既然每一次都是新的`i` 为什么能记得上一个循环的是几？
这里看了看阮一峰 