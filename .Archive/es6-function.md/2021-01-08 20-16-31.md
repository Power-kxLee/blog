# ES6灌溉垒土: 函数的新玩意儿
[TOC]
`万丈高楼起于垒土` 

## 参数设置默认值
### 参数的基本用法
我们之前设置默认值 还要定义一下变量  用`||`运算符
```
function a(b){
    b = b || 'hello word'
    return b
}
a() // hello word
a('哈哈') // 哈哈
```
这也有个问题 我要传入一个布尔值 `false` 也会返回了`hello word`
所以还需要进一步判断参数是不是真的被传值`type b === undefined`
太麻烦了是不是

ES6 就允许我们直接在参数定义默认值，写在参数后面
```
function a(b = 'hello word') {
    return b
}
a() // 'hello word'
a('哈哈') // '哈哈'
a(false) // false
```
舒服多了 清洁多了 心情也好很多了 要注意的是
用参数默认值声明了之后 不能继续用`let` 和 `const` 重复声明
```
function a(b = 'hello word') {
    let b = '22'
    const b = '33'
}
// 都会报错
```
上面代码块允许结果都会报错
使用参数默认值 函数之间的参数名字不能相同
```
function a(b) {....}  //不报错

function c(b = 1) {...} // 报错
```
参数默认值不是求的默认值 而是会每一次都会计算的表达式 得到的结果
有点绕 直接看例子就知道了
```
let c = 1
function a(b = 99+1 - c) {
    return b
}
a() // 99
```
默认值的结果 不是直接传入 都是通过计算得到的  

### 跟解构赋值结合使用
参数还能通过解构方式
```
function a({x, y=44}) {
    return [x, y]
}
let obj = {
    a: 1,
    x: 3,
    y: 4
}
a(obj) // [3, 4]
a({x:1}) // [1, 44]
a({y:2})  // [undefined, 2]
a({}) // [undefined, 44]
a() // 会报错
```
参数通过解构对象的形式 很方便获得 我想要的值
要注意的是 为什么参数不传入 会报错呢？ 而不是理想中的 ` [undefined, 44]` 结果
刚刚什么参数都没传入 是因为没有提供到参数(也就是对象) 进行解构处理 直接报错了

怎么办呢 既然知道问题是没有提供对象给解构 那么我们就设置一个空的对象不就行了
```
function a({x, y=44} = {}) {
    return [x, y]
}
a() // [undefine, 44]
```
这就是想要的结果`[undefine, 44]`

#### 具体实例呢？
我们写一个业务需求 封装一个插件框架 
只暴露我们内部需要的属性 其他的一律丢给外面去处理
以封装axios为例, 直接处理get 和 post统一的写法
```
function axio(url, {data = {}, method= 'get'}) {
    xxx // 业务逻辑
}
axio('http://dev158.com') // 报错 
axio('http://dev158.com', {}) // 执行get请求
```
我发送一个`get`请求 还要我写多一个空对象 可以是可以 但是不科学 能不能省却掉
```
function axio(url, {data = {}, method= 'get'} = {}) {
    xxx // 业务逻辑
}
axio('http://dev158.com') // 执行get请求
```
这样把解构对象 直接设置一个默认值就完事了

#### 小试牛刀
```
function a ({x, y} = {x =1, y=2}) {
    return [x, y]
}

function b ({x=1, y = 2} = {}) {
    return [x, y]
}
``` 
这两个函数 有什么区别？直接看看运行结果
```
// 结果A: 什么都不传
a() // [1, 2]
b() // [1, 2]

// 结果B :只传入一个空的对象
a({}) // [undefined, undefined]
b({}) // [1, 2]

// 结果C: 只传入一个y
a({y: 10}) // [undefined, 10]
b({y: 10}) // [1, 10]
```
我的理解是这样的:
`a`参数 解构对象设置默认值是`{x =1, y=2}`  解构对象内的值 没有设置默认值
`b`参数 解构对象设置的默认值是空的`{}`， 解构对象内的值设置了默认值
解释
* 结果A: 那么当两个函数都没有传入参数的时候 已经被内部的默认值替代了结果 也就是输出的都是一样`[1, 2]`
* 结果B: 当传入了一个空的`{}` 覆盖了函数`a`定义号的默认值 但是解构对象内的值 没有默认值 解构失败所以返回`x`和`y`都是`[undefined, undefined]` 但是函数`b` 就不一样 解构对象内有设置默认值 所以你传入一个空的对象 也会有默认值 最终结果就是`[1,2]`**
* 结果C :其实跟结果B一样的意思 传入的对象没有`x` 那么肯定是`[undefined, 10]`

### 参数默认值的位置
参数默认值最好实在 最后面  为什么？ 因为能很好知道能忽略那些参数 
如果不是写在最后 就会很尴尬
```
function a(x = 1, b) {
    return [x, b]
}

a() // [1, undefined]
```
这还好 问题来了 我只想传入第二个参数 又不影响第一个参数默认值 咋办呢
```
a( , 2) //报错
a(undefined, 2) // [1 , 2]
```
哈哈 很蠢很尴尬是不是 又绕过去第一个位置设置默认值 还能通过设置undefined 来进行省略
所以嘛 这个默认值写最后面就完事了
### 函数length属性 失真了

```
function fn(a, b, c) {} 
fn.length // 3

function fn(a, b= 1, c) {} 
fn.length // 2

function fn(...values) {} 
fn.length // 0
```
上面的代码看到 只要参数设置了默认值 或者 用`rest`参数 就不会被`length`属性计算在内
不过这也没什么用 要计算参数 可以用`argument`集合来获得长度
(但是在箭头函数内 又不生效 因为没有`argument` )

### 作用域
参数默认值也有自己的作用域
当带有参数默认值的函数初始化的时候 就会有一个独特的作用域
```
var  x = 10
function a (x=1, y =x+1) {
    return y    
}
a() // 2
```
函数初始化的时候 会在自己的作用域 `x`是取第一个定义`x` 而不是全局变量`x` 
所以得到的结果是`2`
```
var  x = 10
function a ( y =x+1) {
    let x = 1
    return y    
}
a() // 11
```
这个例子也是一样 初始化的时候有自己特定作用域  `y =x+1`在作用域内 没有查找到`x` 那么就向上查询 找到了全局变量`x` 
当然了 最终如果`var x = 10`没有定义 那么就会报错 因为找不到变量`x`嘛

## rest参数
rest参数 就是我们经常看到传参的写法`function a(c, ...values)`
用来获得多余的参数 然后把这些参数都放到一个数组集合中
跟`argument`很像是吧 ，但是严格点来说`argument`是一个对象数组 不是真正数组 用的时候还要转一下 箭头函数内还不能用
```
function a(...values) {
    let str = ''
    for (let val of values ) {
        str += val
    }
    return str
}
a('你','好','阿') // 你好阿
```
当然也可以用`argument`获得所有参数，但是还要转一下数组`Array.prototype.slice.call(argument)` 麻烦

要注意的时候 使用`rest`参数之后 不能再有其他参数
```
function a(...values, a) // 报错
```

## 严格模式
函数内部可以设置严格模式
```
function a(){
    'use strict' // 严格模式 
}
```
但是如果有`参数默认值` 、`解构赋值` 等就不能用严格模式 会报错
具体参考[#严格模式](https://es6.ruanyifeng.com/#docs/function#%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F)

## 函数name属性
可以用`name`属性 直接返回函数名
```
function a() {}
a.name  // a
```
了解就行 具体业务中没怎么用得上
## 箭头函数
es6函数改动最方便的 无非就是箭头函数了
```
const a = (x) => x+1;
等同于
const a = function(x) {
    return x + 1
}
```
没有参数传入 直接写个圆括号就行了
```
const a = () => 1
```
如果箭头函数的代码块多余1条 就要用`{}`大括号包住
```
const a = (x) => {let y = x+6; return y + 66}
```
但是如果我要返回一个对象 
```
const a = (x) = ({a:1, b:2})
```
必须要在外面加上括号 不然会报错

箭头函数我们主要能经常用在简化回调函数
```
vue.filte((item, i ) =>item)
```
很方便
### 箭头函数需要注意的点
* `this`指向就是在箭头函数定义的对象 而不是在使用的对象
* 不可以用来做构造函数 也就是不能`new xxx()`
* 不可以使用`argument` 因为在函数内根本没这个 可以用`rest`参数代替

主要注意的是第一点`this`指向问题 在箭头函数内它就是固定的
```
var s = 66
let fn = function(){
    const b = () => {
        console.log(this.s) 
    }
	b()
}
fn.call({s: 1})  // 1
```
上面的例子 其实就很清晰了
箭头函数`b` 生效在`fn`函数内 这个时候`this`就是指向函数定义内生效的对象 也就是`fn`函数 
最后引用的时候 通过`call`引入一个对象 那么就自然是获得这个函数生效的对象`{s:1}`
但是如果箭头函数`b` 改成其他的正常函数 就会调用的是全局变量`s:66` 
所以
* `this`只在绑定的定义时候的作用域 你怎么样调用他也不会改变`this`的指向
#### 能用在什么地方
很好使 我们经常用在回调函数内     让这个`this`固定化 
比如说回调方法内执行 操作的代码
```
var obj = {
    id: 68
    init : function() {
        Vue.nextTick( () =>this.data()}) 
    },
    data : function(){
        console.log('data')
    }
}
```
上面的代码`nextTick`用在的箭头函数 这里的this就是指向外面的`obj`对象 然后就自然去得到`this.data`这个函数呢
其实跟我们之前的写法一样
```
function fn() {
    let _this = this
    Vue.nextTick(function(){ 
        _this.data()
    })    
}
```
es6之前 我们会经常这样定义 在外层定义多一个变量来实现 
所以这里就很清楚了 为什么箭头函数没有`this` 没有`argument` 因为根本就不存在 都是用外面的

#### 不适合的地方
* 定义对象方法的时候 并这个方法要用到`this`
```
const obj = {
    id: 10,
    data: () => {
        console.log(this.id)        
    }    
}
```
当调用`obj.data()`这里会报错 因为this是指向了全局，全局没有找到`id`就报错了
* 回调函数内 需要用在带过来this指向 就不要用箭头函数写了

## 尾调用优化
尾调用 意思就是 
* 在函数最后一步 是执行另外一个函数的
也就是说 最后一步是执行另外一个函数 就是尾调用

首先我们先来了解函数调用栈
我们调用一个函数 会生存一个`调用记录` 保存这个调用位置和内部的变量内存
如果我们调用`a`函数 会形成一个`a`函数的调用记录
`a`函数内 继续调用`b`函数 那么就在会`a`函数的调用记录上 生成一个`b`函数的调用记录
直到这个`b`函数有返回结果内容 才会从调用栈删除这个`b`的调用记录

然后`尾调用优化` 就是 函数的最后一步调用的这个函数 没有使用外部函数的内存 变量等 
就会直接生成一个自己的调用记录 取代外层的调用记录
```
function fn () {
    return function() {
        return '哈哈'
    }
}
```