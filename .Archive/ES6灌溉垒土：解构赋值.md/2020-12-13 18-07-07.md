# ES6灌溉垒土: 解构赋值
`万丈高楼起于垒土` 
解构赋值这个设定，刚看会有点迷惑 迷迷糊糊的 多使用就可以了

## 数组解构赋值
先理一理 es6之前 赋值一直都是这样 变量赋值
```
var a = 1
var b = 'c'
var c = []
var d = {}
```
简简单单也没什么不好 
在es6 可以把一个数据直接解构  直接栗子
```
let [a, b , c] = [1, 2 ,3]
a // 1
b // 2
c // 3
```
数值的解构赋值 是根据对应的位置 对定义的变量进行赋值
这样看还好 但是还有一些头晕晕的操作
```
let [, , a] = [1,2,3]
a // 3
let [a, ...all] = [1,2,3]
a // 1
all// [2,3]

let [a, b, ...all] ] = [1]
a// 1
b// undefined
all// []
```
这里看到 最后一个栗子 b解构 右边没有对应的赋值 
也就是解构失败 返回的是`undefined`
还可以嵌套解构
```
let  [a, [b], d]= [1, [2,3], 4]
a // 1
b // 2
d //4
```
如果解构数组 右边赋值不是一个数组 那么就会报错
```
let [a]= 1
let [a] = 'a'
let [a] = null
let [a] = {}
......
```
这些都会报错
### 默认值
解构赋值都可以提前设置默认值 但是赋值的成员要等于`undefined` 默认值才会生效
```
let [a = 'age'] = []
a // age  

let [a = 'A', b='B"] =['AA']
a // AA
b// b
```
上面代码快 能设置默认值的 都是因为赋值的是`undefined`
```
let [a = 1] = [undefined]
a // 1

let [a = 1] = [null]
a // null
```
这里就很清晰了  反正要设置默认值 只能赋值的是undefined
es6方便很多 适用于很多传参 获得 得到结果是undefined的时候 可以有自己的默认值

所以实际应用的时候 还可以把默认值设置成一个函数
```
function fun() {
   return 'hhah'
}
let [a = fun()] = [1]
// a = 1
```
这里很明显 默认值失效  因为赋值的对象有值
这里能看出其实默认值 是惰性的 当有需要的时候才用到
这里的代码块其实等同于
```
if ( [1] === undefined) {
    a  = fun()
} else {
    a = [1]
 }
```
默认值还可以引用解构的其他值 但是被引用的值 得要提前声明 看看栗子
```
let [a = 1, b= a] = [] // a =1  b=1
let [a =1, b=a] = [2] // a=2, b=2
let [a=1, b=a]  =[2,3] // a =2, b=3
let [a=b, b=1] = [] //  这里会报错
```
所以也一目了然  你要引用解构中的其他值 这个值得要提前声明

## 对象的解构赋值
对象的解构赋值 是相对来说比较常用的 我们在模块与模块之间的导入 
只赋值引用需要用到的代码块 就很经常见到

```
let {a, b, c} = {c:3, a:1 , b:2 }
a//1
b//2
c//3
```
这个栗子可以看到 解构数组和 解构对象的区别
解构数组: 是根据赋值的顺序一一对应进行排序，最终返回取值
解构对象: 赋值的顺序不重要，在哪个索引都可以 最重要是被赋值的属性 必须和 变量同名
```
let {c} = {d:'1'}
c // undefined
```
这个例子 要解构赋值到左边的变量`c` 但是右边的属性 找不到`c` 所以就是`undefined` 这里很数组解构千万别混了
刚刚上面提到 我们经常应用到某些模块的代码块传入 就可以用到对象解构
```
let {nextTick, Set} = Vue
nextTick(function(){
  set(obj, '111')
 })
 
 let {print} = window
 print() 
```
### 变量的别名匹配
老板: 这个名字跟引用的组件方法相同 给我改
可以的 谁让我是打工人呢
```
let  {a: x} = {a: 2}
x // 2
a // 报错
```
也就是说 如果要变量别名  `a`只是一个匹配的模式 匹配后结果真正被赋值到的变量是`x` 所以`a`不是变量 肯定报错了
对象解构也可以多层解构 其实跟数值一样的
```
var obj = {
    a: [
        'how',
        {
            age: '28'
        }
    ]
}

let {a: [x , {age  }]} = obj
x // how
age  // 28
```
这里刚开始看 自己也有点迷迷糊糊(??啥玩意呢) 
但是一段一段拆开看 也是有意思

这里解构obj这个对象 根据解构匹配的模式`a`, 是一个数组 在解构最终赋值另外的变量别名 `x` 和`age`
刚刚说了`a`的模式是一个数组 那么自然是用`[]`数组的写法
数据解构是根据顺序去解构赋值 也就是说 这个`x`定义成什么都不重要 最终肯定得到的是`how` 因为大家对应的都是索引0
后面就简单 还要解构这个`age` 是一个对象 获得值也就是`28`
这个例子同时应用了解构数组 和 解构对象的原理 如果在深入3层 4层 还要更加的复杂 原理得明白

问题来了 我就是像解构匹配整个`a`对象
上面的栗子解构赋值 里面的`a` 已经说了 是一个匹配的模式 模式肯定不能作为变量啊 
所以很简单
```
var obj = {
    a: [
        'how',
        {
            age: '28'
        }
    ]
}

let {a, a: [x , {age  }]} = obj
x // how
age  // 28
a // ['how',{ age: '28'} ]
```
只需要再把a进行解构 通过变量的方法 而不是匹配的模式 就可以了 

还有一种栗子 就是解构深层的对象
```
let allobj = {
    obj: {
        obj1: {
            obj2: {
                a: 'hello'
            }
        }
    }
}
let {obj, obj:{ obj1}, obj:{obj1:{obj2:{a}}}  } = allobj
obj // obj:    Object

obj1//  obj1:  Object
a // hello
```
这个代码块很深 很绕 但是只对`obj` `obj1` 和`a` 解构赋值

还可以嵌套其他变量赋值
```
let obj = {}
let arr = []
let {a:obj.age , b:arr[0] }  = {a:1 , b:2}
obj // {age: 1}
arr// [2]
```

### 默认值
解构对象也可以设置默认值 跟数值一样 要严格等于`undefined`
```
let {x, y=5} = {x:5}
x//5
y//5

let {x:y=5} = {y=1}
y // 5
```
反正让默认值生效  右边赋值的要等于`undefined`就行了

数值本质其实也是一个对象 所以也可以对数值进行解构
```
let arr =[1, 2,3]

let {0,1,2} = arr
0// 1
1//2
2//3
```
这里解构之后 数值的建值0等于对应的值是1
所以也可以直接写一段代码块 很方便的定义 数组的第一个 和最后一个
```
let arr =[1, 2,3]
let first = arr[0]
let firse = arr[arr.length - 1]
用解构方式赋值
let {0:first, [arr.length-1]: last}  = arr
first // 1
last //3
```

## 字符串的解构赋值
字符串也可以用对象 和数组的方式解构
会有什么的结果呢
```
let [a,b,c,d,e] = 'hello'
a// h
b//e
c//l
d//l
```
用数组解构字符串 得到的跟本质上 根据顺序返回对应的值

```
let {length} = 'hello'
length // 5
```
字符串有类似数组一样 获得长度`length`属性 也可以直接这样获得长度

## 数值、布尔值的解构赋值
其实跟字符串解构一样 就是获得字符串能有的属性
解构赋值 只要不是数组和对象 右边一律按转成对象解构处理
```
let {toString: t} = 1
let {toString: t} = true
 t === Number.prototype.toString // true
 t === Boolean.prototype.toString // true
```
数值和布尔值 都有一个属性 `toString` 可以转成字符串 当然 其他拥有的属性也可以进行解构

## 函数参数也可以解构赋值
函数的参数可以用解构赋值方式
```
function add([a, b]) {
    return a + b
} 
add([1, 3]) // 4
```
用来循环得到结果也很方便
```
[ [1,2],[3,4],[5,6] ].map(( [a,b] ) => a+b)
 // [3, 7, 11]
```
### 默认值
也是可以用默认值 一样的
```
function move({x=0, y=0} = {}) {
    return [x, y]
}
move ({x:3 , y:3})  // [3,3]
move()// [0, 0]
move({x:3}) // [3, 0]
```
上面代码 这个`move`函数参数是一个对象 这里能提前通过解构方式 取得即将要传入对象的x 和 y
还有另外一种结果 为`move`设置默认值 
```
function move({x,y } = {x=0, y=0}) {
    return [x, y]
}
move ({x= 1, y=2}) // [1, 2]
move({x = 1}) // [1, undefined]
move({}) // [undefined, undefined]
move() // [0, 0]
```
上面代码块不是对 解构设置默认值 而是对`move`这个函数设置了一个默认值
然后传参 传入一个缺失的对象属性时候 另外一个找不到就是等于`undefined`
找到的属性 就被后面传入的对象赋值 也就变成了`1`
两者区别在这里 实际上怎么样取舍
如果我传入一个对象 这个对象的属性我未知的 我需要用到后面操作 那么我可以提前设置一个值 
然后我传入一个对象 我想要知道这个属性是否存在的 那么可以通过对`move`进行提前设置默认值 当传入的参数属性 匹配不上 自然就是`undefined`
那么就知道这个属性不存在了

解构还有个很奇怪情况 `undefined`会直接设置成默认值
```
[1， undefined， 3].map(({a='hahah'} )=> a)
[1, haha, 3]
```
这里因为解构有`undefined` 解构过程中会触发设置的默认值 也就是`hahah`

## 圆括号的情况
* 变量声明语句 不允许使用圆括号
```
let [(a)] = 1
let {p:(a)} = {}
let {(p:a)} = {}
```
这些都是错的 因为都是变量声明语句 不能用圆括号
* 函数也属于变量声明 也不能带圆括号

```
// 报错
function f([(z)]) { return z; }
// 报错
function f([z,(x)]) { return x; }
```
* 赋值语句模式 也不能带圆括号
```
([a,b]) = [1, 2]
({p:a}) = {p:1}
```
这里上面代码块整个模式都在圆括号中 所以暴多

那什么时候能用呢 只有一种情况: 不能是声明变量语句 赋值语句中 不能带模式 
就这么简单
```
([a]) = [1]
({p: (a)} = {p:1})
```
来看看上面代码 
第一行:  这个模式是取数组第一个成员 和 圆括号无关 也不是声明变量语句
第二行 这个对象解构有带模式语句 模式是`p`  圆括号没包括模式 所以是对的

## 用途
这个解构赋值 实际上有啥用呢？  看看下面栗子
### 交换变量的值
```
let x = 1
let y = 2
[x, y] = [y, x]
x// 2
y// 1
```
这样就能很快的也很直观的 对两个变量更改值 不用这样写

### 函数的用法

我们写代码块 一个函数想反悔多个结果 都是操作在数据和对象上 用解构能很方便的取得我要的属性或者值
```
//数值解构
function arr() {
    return [1,2,3,5]
}
let [a, b ,c, d]  = arr()

// 对象解构(比较常用)
function obj (){
    return {
        length,
        head
    }
}
let {length, head} = obj()
length() 
head()

```
常用的都是对象解构 我要取得另外一个模块的方法 我只解构某个代码块 而不用全部代码块全部进行解析

## 函数参数的定义
解构赋值 可以根据定义的参数 是有顺序 还是无顺序的
```
//有顺序
function arry ([a, b ,c] ) {...}
arry([1, 2 ,3])

//无顺序
functuio obj({a, b,c}) {...}
obj({c:1, a:5, b: 7})
```

## 提取